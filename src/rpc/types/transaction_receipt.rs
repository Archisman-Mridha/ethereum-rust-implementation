use ethers_core::types::{Address, Bloom, Log, H256, U256, U64};
use serde::{Deserialize, Serialize};

// Transaction receipt contains transaction outcomes (status, logs etc.).
#[derive(Serialize, Deserialize, Clone)]
pub struct TransactionReceipt {

  // Cryptographically generated unique id of the transaction.
  pub transactionHash: Option<H256>,

  #[serde(rename = "type")]
  pub transactionType: U256,

  pub blockHash: Option<H256>,
  pub blockNumber: Option<U256>,

  // Index of the transaction, in the transaction bundle of the related block.
  #[serde(rename = "transactionIndex")]
  pub indexInTransactionBundle: Option<U256>,

  pub from: Address,
  pub to: Option<Address>,

  // Address of the contract created, if the transaction represents deployment of a contract.
  #[serde(rename = "contractAddress")]
  pub contractAddressCreated: Option<Address>,

  // It's the total amount of gas, used when this transaction was executed in the block.
  // Mathematically, cumulativeGasUsed = total gas used by transactions before this one + gas used
  // by this transaction alone.
  pub cumulativeGasUsed: U256,

  // Gas used by this transaction alone.
  pub gasUsed: Option<U256>,

  // The price (base fee + priority fee) paid post-execution by the transaction.
  pub effectiveGasPrice: U256,

  // Represents whether the transaction succeeded (when value is 1) or failed (when value is 0).
  // It was introduced in EIP 658.
  // Refer - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-658.md.
  pub status: Option<U64>,

  // Root hash (or Merkle root) of the state trie. EIP 98 makes this field optional.
  #[serde(rename = "root")]
  pub stateTrieRootHash: Option<H256>,

  /*
    Logs :

    A smart contract stores information in blockchain in two distinct ways: account storage and logs.
    Account storage contains any data that defines the smart contract state and that the contract
    can access. Logs are used to store information that is not required by the contract but must be
    accessed by other off chain applications (front end, analytics etc). It is also worth noting
    that log storage is much cheaper than account storage.

    When a smart contract wants to log data, its 'emits an event', which is then written to the
    transaction receiptâ€™s log records.

    A single log record includes both topics and data. Topics is a list that includes the signature
    of the event as well as any indexed fields. A single log record can have up to four topics in it.
    In general, any data that is likely to appear in a log search should be stored in topics as they
    are indexed. Any other information is stored into the data field.
  */
  pub logs: Vec<Log>,
  /*
    Refer : https://www.youtube.com/watch?v=bgzUdBVr5tE to understand what are bloom filters.

    When a block is generated or verified, the address of any logging contract, and all the indexed
    fields from the logs generated by executing those transactions are added to a bloom filter,
    which is included in the block header. The actual logs are not included in the block data, to
    save space.

    When an application wants to find all the log entries from a given contract, or with specific
    indexed fields (or both), the node can quickly scan over the header of each block, checking the
    bloom filter to see if it may contain relevant logs. If it does, the node re-executes the
    transactions from that block, regenerating the logs, and returning the relevant ones to the
    application.

    Reference : https://ethereum.stackexchange.com/questions/3418/how-does-ethereum-make-use-of-bloom-filters/3426.
  */
  pub logsBloom: Bloom
}