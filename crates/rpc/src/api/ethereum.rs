use crate::types::{
  block::RichBlock, smart_contract_call_request::SmartContractCallRequest,
  transaction::Transaction, transaction_receipt::TransactionReceipt
};
use ethers_core::types::{
  transaction::eip2930::AccessListWithGasUsed, Address, BlockId, BlockNumber, Bytes, H256, U256, U64
};
use jsonrpsee::proc_macros::rpc;
use jsonrpsee_core::RpcResult;
use serde::Serialize;

// API spec for an Ethereum node : https://github.com/ethereum/execution-apis.
#[rpc(server)]
pub trait EthereumApi {

  // Returns protocol version being followed being followed by this node, encoded as a string
  // (quotes are necessary).
  #[method(name = "eth_protocolVersion")]
  fn protocolVersion(&self) -> RpcResult<u64>;

  // Returns an object with data about the sync status of this node (if the synchronization process
  // is currently ongoing), otherwise 'false'.
  #[method(name = "eth_syncing")]
  fn isSyncing(&self) -> RpcResult<SyncStatus>;

  /*
    Coinbase is an account specified during the node startup. Rewards earned due to mining /
    validating blocks is deposited in this account.
    The coinbase address is registered as the block author for the blocks created in this node.
  */
  // Returns the coinbase address.
  #[method(name = "eth_coinbase")]
  fn coinbase(&self) -> RpcResult<Address>;

  // Returns list of addresses of accounts that this node knows about.
  #[method(name = "eth_accounts")]
  fn accounts(&self) -> RpcResult<Vec<Address>>;

  // Returns the block-number of the most recent block that this node knows about.
  #[method(name = "eth_blockNumber")]
  fn mostRecentBlock(&self) -> RpcResult<U256>;

  // Returns the Chain ID, that this node used, to sign transactions at the latest best block.
  // Returns 'none' if the block proposal process didn't start.
  #[method(name = "eth_chainId")]
  fn chainIdUsedInTransactionSigningAtLatestBestBlock(&self) -> RpcResult<U64>;

  // Returns information about the block with the given block-number.
  #[method(name = "eth_getBlockByNumber")]
  fn blockWithNumber(&self,
                     number: BlockNumber,

                     // If true, then returns full transaction objects, otherwise just the
                     // transaction hashes.
                     full: bool
                    ) -> RpcResult<Option<RichBlock>>;

  // Returns the number of transactions in the block with the given block-hash.
  #[method(name = "eth_getBlockTransactionCountByHash")]
  fn transactionCountInBlockWithHash(&self, hash: H256) -> RpcResult<Option<U256>>;

  // Returns the number of transactions in the block with the given block-number.
  #[method(name = "eth_getBlockTransactionCountByNumber")]
  fn transactionCountInBlockWithNumber(&self, number: BlockNumber) -> RpcResult<Option<U256>>;

  // TODO: Explain what are uncle blocks.
  // Retruns uncles count for the block with the given block-hash.
  #[method(name = "eth_getUncleCountByBlockHash")]
  fn unclesCountForBlockWithHash(&self, hash: H256) -> RpcResult<U256>;

  // Returns uncles count for the block with the given block-number.
  #[method(name = "eth_getUncleCountByBlockNumber")]
  fn unclesCountForBlockWithNumber(&self, number: BlockNumber) -> RpcResult<U256>;

  // Returns the transaction with the given transaction-hash.
  #[method(name = "eth_getTransactionByHash")]
  async fn transactionWithHash(&self, hash: H256) -> RpcResult<Option<Transaction>>;

  // Returns the transaction present in the given index of the transaction bundle of the block with
  // the given block-hash.
  #[method(name = "eth_getTransactionByBlockHashAndIndex")]
  async fn transactionAtIndexInBlockWithHash(&self,
                                             hash: H256,
                                             index: usize) -> RpcResult<Option<Transaction>>;

  // Returns the transaction present in the given index of the transaction bundle of the block with
  // the given block-number.
  #[method(name = "eth_getTransactionByBlockNumberAndIndex")]
  async fn transactionAtIndexInBlockWithNumber(&self,
                                             number: BlockNumber,
                                             index: usize) -> RpcResult<Option<Transaction>>;

  // Returns the receipt generated by the transaction with the given transaction-hash.
  #[method(name = "eth_getTransactionReceipt")]
  async fn transactionReceipt(&self, hash: H256) -> RpcResult<Option<TransactionReceipt>>;

  // Returns balance of the given account / address (in the context of the latest block / block with
  // the given block number).
  #[method(name = "eth_getBalance")]
  fn balance(&self, address: Address, blockNumber: Option<BlockId>) -> RpcResult<U256>;

  // Returns the data stored at the storage slot with the given id (in the context of the latest
  // block / block with the given block number).
  #[method(name = "eth_getStorageAt")]
  fn dataStoredAt(&self,
                  address: Address,
                  index: U256,
                  blockNumber: Option<BlockId>) -> RpcResult<H256>;

  // Returns the nonce of the given account (in the context of the latest block / block with the
  // given block number).
  #[method(name = "eth_getTransactionCount")]
  fn accountNonce(&self, address: Address, blockNumber: Option<BlockId>) -> RpcResult<U256>;

  // Returns the bytecode of the smart-contract with the given address (in the context of the latest
  // block / block with the given block number).
  #[method(name = "eth_getCode")]
  fn bytecode(&self, address: Address, blockNumber: Option<BlockId>) -> RpcResult<Bytes>;

  // Executes the given smart-contract (in the context of the latest block / block with the given
  // block number) without creating a transaction on the blockchain. The execution result is then
  // returned.
  #[method(name = "eth_call")]
  fn callSmartContract(&self,
                       request: SmartContractCallRequest,
                       blockNumber: Option<BlockId>) -> RpcResult<Bytes>;

  // Returns access-list for the given transaction (in the context of the latest block / block with
  // the given block number). It also returns the gas (estimated if the transaction isn't corrently
  // mined) usage of the transaction (including the access-list).
  #[method(name = "eth_createAccessList")]
  async fn accessListAndGasUsed(&self,
                                request: SmartContractCallRequest,
                                blockNumber: Option<BlockId>) -> RpcResult<AccessListWithGasUsed>;

  // Returns the estimate gas required for the execution of the given smart contract (in the context
  // of the latest block / block with the given block number).
  #[method(name = "eth_estimateGas")]
  async fn estimateGas(&self,
                        request: SmartContractCallRequest,
                        blockNumber: Option<BlockId>) -> RpcResult<U256>;

  // Returns current gas price.
  #[method(name = "eth_gasPrice")]
  fn gasPrice(&self) -> RpcResult<U256>;

  // ... TODO: Define remaining methods.
}

#[derive(Serialize, Clone)]
pub enum SyncStatus {
  Info(SyncInfo),
  None
}

#[derive(Serialize, Clone)]
pub struct SyncInfo { }